# Deploy workflow - Deploy install script to get.pongogo.com
name: Deploy

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version being deployed (e.g., v0.1.0)'
        required: true
        type: string
  release:
    types: [published]

env:
  AZURE_STORAGE_ACCOUNT: pongogodownloads
  AZURE_RESOURCE_GROUP: pongogo-rg

jobs:
  deploy-install-script:
    name: Deploy Install Script
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'release' && !github.event.release.prerelease)

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="${{ github.event.release.tag_name }}"
          fi
          # Remove 'v' prefix if present for pip install
          VERSION_CLEAN="${VERSION#v}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_clean=${VERSION_CLEAN}" >> $GITHUB_OUTPUT

      - name: Prepare install script
        run: |
          mkdir -p deploy

          # Create index.html that serves the script
          cat > deploy/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>ðŸ¦§ Pongogo Installer</title>
            <meta http-equiv="refresh" content="0; url=install.sh">
          </head>
          <body>
            <p>Redirecting to <a href="install.sh">install.sh</a>...</p>
          </body>
          </html>
          EOF

          # Create install script with Docker requirement
          cat > deploy/install.sh << 'SCRIPT'
          #!/bin/bash
          # Pongogo Installer
          # Usage: curl -sSL https://get.pongogo.com | bash

          PONGOGO_VERSION="__VERSION__"

          set -e

          # Colors (only if terminal supports it)
          # Aligned with Pongogo style guide: canopy (success), durian (warning),
          # racer (error), mist (info), orang (brand). Using bold variants for
          # legibility on both light and dark terminal backgrounds.
          if [ -t 1 ]; then
              GREEN='\033[1;32m'   # canopy - success
              YELLOW='\033[1;33m'  # durian - warning
              RED='\033[1;31m'     # racer - error
              CYAN='\033[1;36m'    # mist - info
              ORANGE='\033[38;5;208m'  # orang - brand (256-color)
              BOLD='\033[1m'
              NC='\033[0m'
          else
              GREEN='' YELLOW='' RED='' CYAN='' ORANGE='' BOLD='' NC=''
          fi

          info() { echo -e "${GREEN}âœ“${NC} $1"; }
          warn() { echo -e "${YELLOW}âš ${NC} $1"; }
          error() { echo -e "${RED}âœ—${NC} $1"; exit 1; }

          # Detect OS
          IS_WSL=false
          IS_MACOS=false
          IS_LINUX=false

          if [[ "$OSTYPE" == "darwin"* ]]; then
              IS_MACOS=true
          elif grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; then
              IS_WSL=true
          else
              IS_LINUX=true
          fi

          # ASCII art header (brand orange)
          printf '\n'
          printf "${ORANGE}"
          printf '     ___  ____  _  ___________  _________\n'
          printf '    / _ \\/ __ \\/ |/ / ___/ __ \\/ ___/ __ \\\n'
          printf '   / ___/ /_/ /    / (_ / /_/ / (_ / /_/ /\n'
          printf '  /_/   \\____/_/|_/\\___/\\____/\\___/\\____/\n'
          printf "${NC}\n"
          echo -e "  $PONGOGO_VERSION               ${BOLD}~ Go, Pon-go-go! ~${NC}"
          if $IS_WSL; then
              echo -e "  ${CYAN}(WSL detected)${NC}"
          fi
          printf '\n'

          # Check Docker
          if ! command -v docker &> /dev/null; then
              echo -e "${RED}âœ—${NC} Docker is required but not installed."
              echo ""
              if $IS_WSL; then
                  echo "WSL requires Docker Desktop for Windows with WSL integration:"
                  echo ""
                  echo "  1. Install Docker Desktop: https://docs.docker.com/desktop/install/windows-install/"
                  echo "  2. Open Docker Desktop Settings â†’ Resources â†’ WSL Integration"
                  echo "  3. Enable integration for your WSL distro"
                  echo "  4. Restart your WSL terminal"
              else
                  echo "Install Docker:"
                  echo "  macOS:   brew install --cask docker"
                  echo "  Linux:   https://docs.docker.com/engine/install/"
              fi
              exit 1
          fi

          if ! docker info &> /dev/null 2>&1; then
              echo -e "${YELLOW}âš ${NC} Docker is installed but not running."
              if $IS_WSL; then
                  echo ""
                  echo "Start Docker Desktop from Windows, then re-run this installer."
                  echo ""
                  echo "If Docker Desktop is running but docker commands fail:"
                  echo "  1. Open Docker Desktop Settings â†’ Resources â†’ WSL Integration"
                  echo "  2. Ensure your WSL distro is enabled"
                  echo "  3. Restart your WSL terminal: wsl --shutdown (from PowerShell)"
                  exit 1
              fi
              read -p $'Would you like to start Docker? \033[94m[Y/n]:\033[0m ' -r < /dev/tty
              echo ""
              if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                  echo "Starting Docker..."
                  if $IS_MACOS; then
                      open -a Docker
                  elif command -v systemctl &> /dev/null; then
                      # Try rootless docker first, then system docker
                      if systemctl --user start docker 2>/dev/null; then
                          echo "Started rootless Docker"
                      elif sudo systemctl start docker 2>/dev/null; then
                          echo "Started system Docker"
                      else
                          echo ""
                          echo -e "${RED}Failed to start Docker.${NC}"
                          echo ""
                          echo "Try: sudo systemctl start docker"
                          echo ""
                          echo "If Docker requires sudo, add yourself to the docker group:"
                          echo "  sudo usermod -aG docker \$USER"
                          echo "  (then log out and back in)"
                          echo ""
                          error "Please start Docker manually and re-run the installer."
                          exit 1
                      fi
                  else
                      error "Unable to start Docker automatically. Please start it manually."
                      exit 1
                  fi
                  # Wait for Docker to be ready (try with and without sudo)
                  echo "Waiting for Docker to start..."
                  for i in {1..30}; do
                      if docker info &> /dev/null 2>&1 || sudo docker info &> /dev/null 2>&1; then
                          info "Docker is now running"
                          break
                      fi
                      sleep 2
                  done
                  # Verify Docker is accessible
                  if ! docker info &> /dev/null 2>&1 && ! sudo docker info &> /dev/null 2>&1; then
                      error "Docker failed to start. Please start it manually and re-run the installer."
                      exit 1
                  fi
              else
                  error "Docker must be running to continue."
                  exit 1
              fi
          fi

          # Check if docker works without sudo
          if ! docker info &> /dev/null 2>&1; then
              if sudo docker info &> /dev/null 2>&1; then
                  echo ""
                  echo -e "${YELLOW}âš ${NC} Docker requires sudo (you're not in the docker group)."
                  echo ""
                  echo "To fix this, run:"
                  echo "  sudo usermod -aG docker \$USER"
                  echo ""
                  echo "Then log out and back in (required for group changes to take effect)."
                  echo ""
                  echo "After logging back in, re-run this installer."
                  exit 1
              else
                  error "Docker is not accessible."
                  exit 1
              fi
          fi

          info "Docker is available"

          # Pull the image
          info "Pulling Pongogo Docker image..."
          docker pull pongogo.azurecr.io/pongogo:stable

          # Install pongogo CLI wrapper
          PONGOGO_BIN="$HOME/.local/bin"
          mkdir -p "$PONGOGO_BIN"
          cat > "$PONGOGO_BIN/pongogo" << 'PONGOGO_CLI'
          #!/bin/bash
          # Pongogo CLI wrapper - runs commands in Docker container
          # Special commands (uninstall, help) run on host

          case "$1" in
            uninstall)
              echo "ðŸ¦§ Pongogo Uninstaller"
              echo "====================="
              echo ""

              # Parse flags
              FORCE=false
              DEBUG=false
              for arg in "$@"; do
                case "$arg" in
                  --force|-f) FORCE=true ;;
                  --debug|-d) DEBUG=true ;;
                esac
              done

              if ! $FORCE; then
                echo "This will remove the Pongogo CLI wrapper and MCP configuration."
                echo ""
                read -p $'Continue with uninstall? \033[94m[y/N]:\033[0m ' -r < /dev/tty
                echo ""
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                  echo "Uninstall cancelled."
                  exit 0
                fi
              fi

              # Remove CLI wrapper first (before Docker image removal)
              if [ -f "$HOME/.local/bin/pongogo" ]; then
                rm "$HOME/.local/bin/pongogo"
                echo "âœ“ Removed ~/.local/bin/pongogo"
              fi

              # Run cleanup via Docker (handles all config file cleanup)
              CLEANUP_ARGS=""
              if $DEBUG; then
                CLEANUP_ARGS="--debug"
              fi

              if docker image inspect pongogo.azurecr.io/pongogo:stable &> /dev/null 2>&1; then
                # Build volume mounts - always mount project dir
                MOUNT_ARGS="-v $(pwd):/project:z"
                # Only mount ~/.claude.json if it exists (avoid creating directory)
                if [ -f "$HOME/.claude.json" ]; then
                  MOUNT_ARGS="$MOUNT_ARGS -v $HOME/.claude.json:/root/.claude.json:z"
                fi
                # Run as host user to ensure file permission compatibility
                # Show errors in debug mode, suppress otherwise for cleaner output
                if $DEBUG; then
                  docker run --rm --user "$(id -u):$(id -g)" $MOUNT_ARGS -w /project \
                    --entrypoint pongogo-cleanup \
                    pongogo.azurecr.io/pongogo:stable \
                    $CLEANUP_ARGS || true
                else
                  docker run --rm --user "$(id -u):$(id -g)" $MOUNT_ARGS -w /project \
                    --entrypoint pongogo-cleanup \
                    pongogo.azurecr.io/pongogo:stable \
                    $CLEANUP_ARGS 2>/dev/null || true
                fi
              else
                echo "âš  Docker image not found, skipping config cleanup"
                echo "  Manually remove 'pongogo-knowledge' from .mcp.json and .claude/ configs"
              fi

              # Offer to remove .pongogo directory (skip prompt if --force)
              if [ -d ".pongogo" ]; then
                if $FORCE; then
                  rm -rf .pongogo
                  echo "âœ“ Removed .pongogo/"
                else
                  echo ""
                  read -p $'Remove .pongogo/ directory (config and instructions)? \033[94m[y/N]:\033[0m ' -r < /dev/tty
                  echo ""
                  if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -rf .pongogo
                    echo "âœ“ Removed .pongogo/"
                  fi
                fi
              fi

              # Offer to remove slash commands (skip prompt if --force)
              if ls .claude/commands/pongogo-*.md &> /dev/null 2>&1; then
                if $FORCE; then
                  rm -f .claude/commands/pongogo-*.md
                  echo "âœ“ Removed Pongogo slash commands"
                else
                  echo ""
                  read -p $'Remove Pongogo slash commands from .claude/commands/? \033[94m[y/N]:\033[0m ' -r < /dev/tty
                  echo ""
                  if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f .claude/commands/pongogo-*.md
                    echo "âœ“ Removed Pongogo slash commands"
                  fi
                fi
              fi

              # Offer to remove Docker image (skip prompt if --force)
              if docker image inspect pongogo.azurecr.io/pongogo:stable &> /dev/null 2>&1; then
                if $FORCE; then
                  docker rmi pongogo.azurecr.io/pongogo:stable
                  echo "âœ“ Removed Docker image"
                else
                  echo ""
                  read -p $'Remove Docker image? \033[94m[y/N]:\033[0m ' -r < /dev/tty
                  echo ""
                  if [[ $REPLY =~ ^[Yy]$ ]]; then
                    docker rmi pongogo.azurecr.io/pongogo:stable
                    echo "âœ“ Removed Docker image"
                  fi
                fi
              fi

              echo ""
              echo "Pongogo uninstalled. Restart any running Claude Code sessions to complete removal."
              ;;

            upgrade)
              echo "ðŸ¦§ Upgrading Pongogo..."
              echo ""

              # Pull latest stable image
              if docker pull pongogo.azurecr.io/pongogo:stable; then
                echo ""
                echo "âœ… Upgrade complete!"
                echo ""
                echo "To use the new version:"
                echo "  1. Exit Claude Code (or restart the terminal)"
                echo "  2. Re-enter Claude Code"
                echo "  3. Run /mcp to verify Pongogo is connected"
              else
                echo ""
                echo "âŒ Upgrade failed. Check your Docker installation and network connection."
                exit 1
              fi
              ;;

            --help|-h|help)
              echo "ðŸ¦§ Pongogo - AI agent knowledge routing"
              echo ""
              echo "Usage: pongogo <command> [options]"
              echo ""
              echo "Commands:"
              echo "  init          Initialize Pongogo in current directory"
              echo "  setup-mcp     Configure Claude Code MCP server"
              echo "  upgrade       Update to latest version"
              echo "  uninstall     Remove Pongogo from this machine"
              echo "  --help        Show this help message"
              echo ""
              echo "Examples:"
              echo "  pongogo init              # Initialize in current repo"
              echo "  pongogo init --minimal    # Minimal installation"
              echo "  pongogo init --force      # Overwrite existing installation"
              echo "  pongogo upgrade           # Update to latest version"
              echo "  pongogo uninstall         # Remove Pongogo (interactive)"
              echo "  pongogo uninstall --force # Remove Pongogo (no prompts)"
              echo "  pongogo uninstall --debug # Verbose output for troubleshooting"
              ;;

            init)
              # Check for updates before init (unless we just installed)
              if [ -z "$PONGOGO_FROM_INSTALLER" ]; then
                # Compare local and remote digests using version.json
                LOCAL_DIGEST=$(docker inspect pongogo.azurecr.io/pongogo:stable --format='{{index .RepoDigests 0}}' 2>/dev/null | cut -d'@' -f2)
                VERSION_JSON=$(curl -s --max-time 5 https://get.pongogo.com/version.json 2>/dev/null)
                REMOTE_DIGEST=$(echo "$VERSION_JSON" | grep -o '"digest"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)

                if [ -n "$REMOTE_DIGEST" ] && [ -n "$LOCAL_DIGEST" ] && [ "$LOCAL_DIGEST" != "$REMOTE_DIGEST" ]; then
                  REMOTE_VERSION=$(echo "$VERSION_JSON" | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4)
                  echo "ðŸ¦§ A newer version of Pongogo is available (v$REMOTE_VERSION)."
                  echo ""
                  read -p $'Update before initializing? \033[94m[Y/n]:\033[0m ' -r < /dev/tty
                  echo ""
                  if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                    echo "Pulling latest version..."
                    docker pull pongogo.azurecr.io/pongogo:stable
                    echo ""
                  fi
                fi
              fi

              # Run init in Docker container
              ENV_ARGS="-e HOST_PROJECT_DIR=$(pwd)"
              if [ -n "$PONGOGO_FROM_INSTALLER" ]; then
                ENV_ARGS="$ENV_ARGS -e PONGOGO_FROM_INSTALLER=1"
              fi
              if [ -t 1 ] && [ -e /dev/tty ]; then
                docker run -it --rm --user "$(id -u):$(id -g)" -v "$(pwd)":/project:z -w /project $ENV_ARGS --entrypoint pongogo pongogo.azurecr.io/pongogo:stable "$@" < /dev/tty
              else
                docker run --rm --user "$(id -u):$(id -g)" -v "$(pwd)":/project:z -w /project $ENV_ARGS --entrypoint pongogo pongogo.azurecr.io/pongogo:stable "$@"
              fi
              ;;

            *)
              # All other commands run in Docker container
              # Use --user to match host user so created files have correct ownership
              # Use :z suffix for SELinux compatibility (Fedora, RHEL, CentOS)
              # Pass HOST_PROJECT_DIR so init can create correct MCP config paths
              # Pass PONGOGO_FROM_INSTALLER if set (skips version check during install)
              # Redirect from /dev/tty for interactive input (works with curl|bash)
              ENV_ARGS="-e HOST_PROJECT_DIR=$(pwd)"
              if [ -n "$PONGOGO_FROM_INSTALLER" ]; then
                ENV_ARGS="$ENV_ARGS -e PONGOGO_FROM_INSTALLER=1"
              fi
              if [ -t 1 ] && [ -e /dev/tty ]; then
                docker run -it --rm --user "$(id -u):$(id -g)" -v "$(pwd)":/project:z -w /project $ENV_ARGS --entrypoint pongogo pongogo.azurecr.io/pongogo:stable "$@" < /dev/tty
              else
                docker run --rm --user "$(id -u):$(id -g)" -v "$(pwd)":/project:z -w /project $ENV_ARGS --entrypoint pongogo pongogo.azurecr.io/pongogo:stable "$@"
              fi
              ;;
          esac
          PONGOGO_CLI
          chmod +x "$PONGOGO_BIN/pongogo"

          # Add to PATH if not already there
          if [[ ":$PATH:" != *":$PONGOGO_BIN:"* ]]; then
              warn "Add ~/.local/bin to your PATH to use 'pongogo' command"
              echo "  Add this to your shell config: export PATH=\"\$HOME/.local/bin:\$PATH\""
          fi

          info "Pongogo installed successfully!"
          echo ""

          # Check if in a git repo and offer to init
          if git rev-parse --git-dir > /dev/null 2>&1; then
              echo "You're in a git repository: $(basename "$(pwd)")"
              if [ -d ".pongogo" ]; then
                  # Already initialized - this is an upgrade, don't prompt
                  info "Pongogo is already initialized in this repo."
                  echo "  To reinitialize: pongogo init --force"
              else
                  read -p $'Would you like to initialize Pongogo here? \033[94m[Y/n]:\033[0m ' -r < /dev/tty
                  echo ""
                  if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                      info "Initializing Pongogo..."
                      PONGOGO_FROM_INSTALLER=1 "$PONGOGO_BIN/pongogo" init
                  else
                      echo ""
                      echo "Run 'pongogo init' when you're ready."
                  fi
              fi
          else
              echo "Navigate to your project and run:"
              echo "  pongogo init"
          fi
          SCRIPT

          # Embed version into install script
          sed -i 's/__VERSION__/${{ steps.version.outputs.version }}/g' deploy/install.sh

          chmod +x deploy/install.sh

          # Verify script is valid bash
          bash -n deploy/install.sh

      - name: Generate version.json
        run: |
          # Get manifest digest from ACR using anonymous token
          TOKEN=$(curl -s "https://pongogo.azurecr.io/oauth2/token?service=pongogo.azurecr.io&scope=repository:pongogo:pull" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
          DIGEST=$(curl -sI -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.docker.distribution.manifest.list.v2+json" \
            "https://pongogo.azurecr.io/v2/pongogo/manifests/stable" | grep -i "^docker-content-digest:" | awk '{print $2}' | tr -d '\r\n')

          if [ -z "$DIGEST" ]; then
            echo "Warning: Could not fetch digest from registry"
            DIGEST="unknown"
          fi

          # Create version.json
          cat > deploy/version.json << EOF
          {
            "version": "${{ steps.version.outputs.version }}",
            "digest": "$DIGEST",
            "released": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          echo "Generated version.json:"
          cat deploy/version.json

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Azure Storage
        run: |
          # Upload to $web container (static website)
          az storage blob upload-batch \
            --account-name ${{ env.AZURE_STORAGE_ACCOUNT }} \
            --destination '$web' \
            --source deploy \
            --overwrite \
            --auth-mode login \
            --content-type "text/html" \
            --pattern "*.html"

          az storage blob upload-batch \
            --account-name ${{ env.AZURE_STORAGE_ACCOUNT }} \
            --destination '$web' \
            --source deploy \
            --overwrite \
            --auth-mode login \
            --content-type "text/x-shellscript" \
            --pattern "*.sh"

          az storage blob upload-batch \
            --account-name ${{ env.AZURE_STORAGE_ACCOUNT }} \
            --destination '$web' \
            --source deploy \
            --overwrite \
            --auth-mode login \
            --content-type "application/json" \
            --pattern "*.json"

          echo "Deployed to https://get.pongogo.com"

      - name: Purge CDN cache
        run: |
          az afd endpoint purge \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --profile-name pongogo-cdn \
            --endpoint-name pongogo-downloads \
            --content-paths "/*" \
            --no-wait || true
